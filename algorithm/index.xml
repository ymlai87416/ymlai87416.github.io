<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Tom personal site</title><link>https://ymlai87416.github.io/algorithm/</link><description>Recent content in Algorithms on Tom personal site</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</managingEditor><webMaster>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 04 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ymlai87416.github.io/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary</title><link>https://ymlai87416.github.io/algorithm/binary/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><author>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</author><guid>https://ymlai87416.github.io/algorithm/binary/</guid><description>Data structure holding bits Boolean[]: 4-20bytes boolean[]: 1bytes BitSet: 1bit
Refer: boolean[] vs. BitSet: Which is more efficient?
Number of bit set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static int NumberOfSetBits(int i) { i = i - ((i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x55555555); i = (i &amp;amp; 0x33333333) + ((i &amp;gt;&amp;gt;&amp;gt; 2) &amp;amp; 0x33333333); return (((i + (i &amp;gt;&amp;gt;&amp;gt; 4)) &amp;amp; 0x0F0F0F0F) * 0x01010101) &amp;gt;&amp;gt;&amp;gt; 24; } static int NumberOfSetBits(int i){ int cnt = 0; while(i !</description></item><item><title>Binary search</title><link>https://ymlai87416.github.io/algorithm/binary_search/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><author>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</author><guid>https://ymlai87416.github.io/algorithm/binary_search/</guid><description>Finding mid Wrong: mid = (high + low) / 2 Correct: mid = low + (high-low)/2
Consider case where high=-4 and low=-5, mid will be -4 which is high, so it will keep looping because you cannot reduce high value.
Finding exact value Where the exact value must be find Inclusive version stop at low &amp;gt; high, while exclusive version stop at low == high.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 private int iterativeInclusive(){ int low = 0, high = nums.</description></item><item><title>Data structures</title><link>https://ymlai87416.github.io/algorithm/data_structure/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><author>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</author><guid>https://ymlai87416.github.io/algorithm/data_structure/</guid><description>Union find Shortcut: ds.uf
Time complexity: O(Î±(n))
Memory complexity: O(n)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class UnionFind { // OOP style int[] p; int[] rank; int[] size; UnionFind(int N) { p = new int[N]; rank = new int[N]; size = new int[N]; for (int i = 0; i &amp;lt; N; i++) p[i] = i; } void init(){ for (int i = 0; i &amp;lt; p.</description></item><item><title>Dynamic programming</title><link>https://ymlai87416.github.io/algorithm/dp/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><author>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</author><guid>https://ymlai87416.github.io/algorithm/dp/</guid><description>Dynamic programming Longest increasing subsequence Very classic algorithm. Time complexity: O(nlog(n)) Space complexity: O(n)
Refer: Longest Increasing Subsequence
Travelling salesman Shortcut: dp.tsp
Time complexity: from O(2!) =&amp;gt; O(2^n) Space complexity: O(2^n)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //this version use adj matrix //please change to use adj list static =11 static boolean[][] vis = new boolean[11][1 &amp;lt;&amp;lt; MAX_NODE]; int travellingSalesman (int end, int mask) { int bitSet = NumberOfSetBits(mask); if(bitSet == point-1){ if((mask &amp;amp; 1) == 0) //mask left only starting position not set.</description></item><item><title>Graph</title><link>https://ymlai87416.github.io/algorithm/graph/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><author>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</author><guid>https://ymlai87416.github.io/algorithm/graph/</guid><description>Graph Data structure Adj list Shortcut: graph.adjlist
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Pair implements Comparable&amp;lt;Pair&amp;gt; { int first; int second; public Pair(int first, int second) { this.first = first; this.second = second; } @Override public int compareTo(Pair o) { if (first &amp;lt; o.first) return -1; else if (first &amp;gt; o.</description></item><item><title>Maths</title><link>https://ymlai87416.github.io/algorithm/math/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><author>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</author><guid>https://ymlai87416.github.io/algorithm/math/</guid><description>Maths Master therom $$ T(n) = aT(\frac{n}{b}) + f(n^d) \begin{cases} &amp;amp; \text{ if } a=b^d, T(n)=O(n^d logn)\ &amp;amp; \text{ if } a&amp;lt;b^d, T(n)=O(n^d)\ &amp;amp; \text{ if } a&amp;gt;b^d, T(n)=O(n^{log_{b}a}) \end{cases} $$
First case:
binary search: $ a=1, b=2, d=0 =&amp;gt; a=b^d, T(n)=O(n^0 * log(n)) = O(log(n))$
sorting: $ a=2, b=2, d=1 =&amp;gt; a=b^d, T(n)=O(n * log(n))$
Third case:
binary tree traverse: $ a=2, b=2, d=0 =&amp;gt; a&amp;gt;b^d, T(n)=O(n^{log_{2}2}) = O(n) $</description></item><item><title>Strings</title><link>https://ymlai87416.github.io/algorithm/string/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><author>ymlai87416@gmail.com (Lai Yiu Ming, Tom)</author><guid>https://ymlai87416.github.io/algorithm/string/</guid><description>KMP searching Time complexity: O(m+n)
Can use to detect longest parlindrom from the beginning
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 final int MAX_N = 1_000_001; char[] T = new char[MAX_N]; char[] P = new char[MAX_N]; // T = text, P = pattern int[] b = new int[MAX_N]; int n, m; // b = back table, n = length of T, m = length of P void kmpPreprocess() { // call this before calling kmpSearch() int i = 0, j = -1; b[0] = -1; // starting values while (i &amp;lt; m) { // pre-process the pattern string P while (j &amp;gt;= 0 &amp;amp;&amp;amp; P[i] !</description></item></channel></rss>