{"version":3,"sources":["components/ToolList.js","components/Dec2BinTool.js","components/ReverseStr.js","components/MultiLine.js","components/Cobyla.js","components/Kelly.js","App.js","serviceWorker.js","index.js"],"names":["ToolList","state","tools","this","setState","title","path","map","tool","i","key","href","style","textAlign","margin","Component","Dec2BinTool","props","dec2BinHelper","debounce","console","log","arr","dec","split","line","trim","filter","length","sameLen","sameLength","result","window","dec2Bin","bin","join","bin2DecHelper","bin2Dec","handleDecChange","e","target","value","handleBinChange","codeUrl","binUrl","wasmModule","WebAssembly","instantiateStreaming","fetch","go","importObject","instance","module","run","className","rows","cols","name","onChange","htmlFor","type","id","checked","flipSameLength","bind","ReverseStr","helper","in","reverse","out","handleChange","MultiLine","concat","multilineInv","input","language","multiline","setLanguage","event","setConcat","readOnly","n","a","Array","arr2","m","arraycopy","x","iox","b","FindMinimum","calcfc","rhobeg","rhoend","iprint","maxfun","fmaxiter","iterationCallback","callbackIterations","mpp","status","total","f","fqueue","resmax","np","mp","rho","parmu","iflag","ifull","parsig","prerec","prerem","con","sim","simi","datmat","vsig","veta","sigbar","dx","w","nfvals","temp","jdrop","ibrnch","L_40","getMaxDiffOfFitnessValues","k","Math","max","PrintIterationResult","undefined","skipVertexIdent","L_140","L_550","phimin","nbest","j","tempa","error","DOT_PRODUCT","PART","ROW","COL","abs","pareta","wsig","weta","sqrt","cvmaxp","cvmaxm","dxsign","trstlp","resnew","barmu","phi","trured","ratio","edgmax","l","pow","cmin","cmax","denom","min","statusText","maxcv","fitness","iterations","cobylb","thisx","ix","ocon","push","Number","MAX_VALUE","shift","apply","nactx","resold","z","zdota","vmultc","sdirn","dxnew","vmultd","iact","mcon","nact","icon","first","L_60","optold","icount","step","stpful","L_70","optnew","isave","vsave","kk","kp","sp","alpha","beta","tot","spabs","acca","accb","zdotv","zdvabs","kw","dd","sd","ss","zdotw","zdwabs","sumabs","src","rowidx","dest","col","colidx","row","from","to","slice","lhs","rhs","sum","kelly1","bankroll","win","odds","fbankroll","parseFloat","fwin","kellyStock1","mean","std","fmean","fstd","setBankroll1","bankroll1","result1","win1","odds1","setWin1","setOdds1","setBankrollM","bankrollM","handleWinMChange","index","items","kellyM","handleOddsMChange","setRowM","rowM","handleRowChange","curLen","rlen","splice","setBankRollS1","optF","ret","meanS1","stdS1","bankrollS1","optFS1","expectRS1","setMeanS1","setStdS1","loadDebug","createRandomStart","maxValue","floor","random","hanldeSubmit","fodds","test","sumB","g","exp","bestx","bestG","curG","calcG","toFixed","kellyStock2","p","q","fp","fq","setBankrollS2","pS2","qS2","gainS2","lossS2","bankrollS2","optFS2","setPS2","setAS2","setQS2","setBS2","return1","returnM","kellyInputStyle","minWidth","display","marginLeft","marginRight","Provider","Node","formula","width","element","onClick","App","basename","exact","component","Kelly","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.e972f0f7.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nclass ToolList extends Component {\n    state = {\n        tools: []\n    }\n\n    componentDidMount(){\n        //hard code all the tools here\n        var arr = [ \n            {\n                title: 'Decimal/Binary converter',\n                path: '#/dec2bin',\n            },\n            {\n                title: 'Reverse string',\n                path: '#/reverseStr',\n            },\n            {\n                title: 'Multiline',\n                path: '#/multiline',\n            },\n            {\n                title: 'Table format to insert SQL',\n                path: '#/table2SQL',\n            },\n            {\n                title: 'Kelly calculator',\n                path: '#/kelly',\n            },\n         ];\n        this.setState({tools: arr})\n    }\n\n    render(){\n        const tools = this.state.tools.map((tool, i) => <li key={i}><a href={\"./\"+tool.path}>{tool.title}</a></li>)\n        const divStyle = {\n            textAlign: 'left',\n            margin: '10px'\n        }\n\n        return(\n            <div style={divStyle}>\n                <h2>All tools</h2> \n                <ul>\n                   {tools}\n                </ul> \n            </div>\n        )\n    }\n}\n\n\nexport default ToolList;","import React, {Component} from 'react';\nimport { debounce } from \"lodash\";\nimport './Dec2BinTool.css';\n\nclass Dec2BinTool extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            dec : \"\",\n            bin : \"\",\n            sameLength: true\n        }\n        this.codeUrl = \"https://github.com/ymlai87416/ymlai87416.github.io/blob/master/mytoolproject/tools/dec2bin/main.go\"\n        this.binUrl = \"https://ymlai87416.github.io/mytool/bin/dec2bin.wasm\"\n        this.wasmModule = null \n    }\n\n    async componentDidMount(){\n        let { instance, module } = await WebAssembly.instantiateStreaming(fetch(this.binUrl), window.go.importObject)\n        this.wasmModule = module\n        await window.go.run(instance)\n    }\n\n    dec2BinHelper = debounce(() => { // this can also dispatch a redux action\n        console.log(\"In dec2BinHelper\")\n        let arr = this.state.dec.split(/\\r?\\n/).map(line=>line.trim()).filter(line => line.length > 0);\n        let sameLen = this.state.sameLength\n\n        let result = window.dec2Bin(...arr, sameLen)\n\n        this.setState({bin: result.join(\"\\n\")})\n    }, 300);\n    \n\n    bin2DecHelper = debounce(() => { // this can also dispatch a redux action\n        console.log(\"In bin2DecHelper\")\n        let arr = this.state.bin.split(/\\r?\\n/).map(line=>line.trim()).filter(line => line.length > 0);\n        let sameLen = this.state.sameLength\n\n        let result = window.bin2Dec(...arr, sameLen)\n\n        this.setState({dec: result.join(\"\\n\")})\n    }, 300);\n\n    \n    handleDecChange = (e) => {\n        this.setState({dec: e.target.value});\n        this.dec2BinHelper()\n    }\n\n    handleBinChange = (e) => {\n        this.setState({bin: e.target.value});\n        this.bin2DecHelper()\n    }\n\n    flipSameLength(){\n        this.setState({sameLength: !this.state.sameLength})\n    }\n\n    render(){\n        return(\n            <div className=\"main\">\n                <h1>\n                    Decimal/Binary converter\n                </h1>\n                <p>Convert a list of decimal to binary format, because Excel does not do it...</p>\n                <br/>\n                <div>\n                    Code URL: <a href={this.codeUrl}>{this.codeUrl}</a>\n                </div>\n                <br/><br/>\n                <div className=\"table\">\n                    <div className=\"tr\">\n                        <span className=\"td\"><h3>Decimal</h3></span>\n                        <span className=\"td\"><h3>Binary</h3></span>\n                    </div>\n                    <div className=\"tr\">\n                        <span className=\"td\">\n                            <textarea className=\"taInput\" rows = \"10\" cols = \"60\" name = \"decimal\" value={this.state.dec}\n                                onChange={this.handleDecChange}/>\n                        </span>\n                        <span className=\"td\">\n                            <textarea className=\"taInput\" rows = \"10\" cols = \"60\" name = \"binary\" value={this.state.bin}\n                                onChange={this.handleBinChange}/>\n                        </span>\n                    </div>\n                </div>\n\n                <span>\n                    <label htmlFor=\"sameLength\"> Same length in result</label>\n                    <input type=\"checkbox\" id=\"sameLength\" checked={this.state.sameLength} onChange={this.flipSameLength.bind(this)}/>\n                </span>\n            </div> \n        )\n    }\n}\n\n\nexport default Dec2BinTool;","import React, {Component} from 'react';\nimport { debounce } from \"lodash\";\nimport './ReverseStr.css';\n\nclass ReverseStr extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            dec : \"\",\n            bin : \"\",\n        }\n        this.codeUrl = \"https://github.com/ymlai87416/ymlai87416.github.io/blob/master/mytoolproject/tools/reversestr/main.go\"\n        this.binUrl = \"/mytool/bin/reversestr.wasm\"\n        this.wasmModule = null \n    }\n\n    async componentDidMount(){\n        let { instance, module } = await WebAssembly.instantiateStreaming(fetch(this.binUrl), window.go.importObject)\n        this.wasmModule = module\n        await window.go.run(instance)\n    }\n\n    helper = debounce(() => { // this can also dispatch a redux action\n        console.log(\"In helper\")\n        let arr = this.state.in.split(/\\r?\\n/).map(line=>line.trim()).filter(line => line.length > 0);\n\n        let result = window.reverse(...arr)\n\n        console.log(result)\n\n        this.setState({out: result.join(\"\\n\")})\n    }, 300);\n    \n    \n    handleChange = (e) => {\n        this.setState({in: e.target.value});\n        this.helper()\n    }\n\n    render(){\n        return(\n            <div className=\"main\">\n                <h1>\n                    Reverse string\n                </h1>\n                <p>Reverse strings</p>\n                <br/>\n                <div>\n                    Code URL: <a href={this.codeUrl}>{this.codeUrl}</a>\n                </div>\n                <br/><br/>\n                <div className=\"table\">\n                    <div className=\"tr\">\n                        <span className=\"td\"><h3>Input</h3></span>\n                        <span className=\"td\"><h3>Output</h3></span>\n                    </div>\n                    <div className=\"tr\">\n                        <span className=\"td\">\n                            <textarea className=\"taInput\" rows = \"10\" cols = \"60\" name = \"decimal\" value={this.state.in}\n                                onChange={this.handleChange}/>\n                        </span>\n                        <span className=\"td\">\n                            <textarea className=\"taInput\" rows = \"10\" cols = \"60\" name = \"binary\" value={this.state.out} />\n                        </span>\n                    </div>\n                </div>\n            </div> \n        )\n    }\n}\n\n\nexport default ReverseStr;","import React, {Component} from 'react';\nimport { debounce } from \"lodash\";\nimport './MultiLine.css';\n\nclass MultiLine extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            input : \"\",\n            result : \"\",\n            language: \"java\",\n            concat: false,\n        }\n        this.codeUrl = \"https://github.com/ymlai87416/ymlai87416.github.io/blob/master/mytoolproject/tools/multiline/main.go\"\n        this.binUrl = \"/mytool/bin/multiline.wasm\"\n        this.wasmModule = null \n    }\n\n    async componentDidMount(){\n        let { instance, module } = await WebAssembly.instantiateStreaming(fetch(this.binUrl), window.go.importObject)\n        this.wasmModule = module\n        await window.go.run(instance)\n    }\n\n    helper = debounce(() => { // this can also dispatch a redux action\n        console.log(\"In helper\")\n\n        let result = \"\"\n        if(this.state.concat)\n            result = window.multilineInv(this.state.input, this.state.language)\n        else\n            result = window.multiline(this.state.input, this.state.language)\n\n        this.setState({result: result})\n    }, 300);\n\n    \n    handleChange = (e) => {\n        this.setState({input: e.target.value});\n        this.helper()\n    }\n\n    setLanguage = (event) => {\n        //console.log(event.target.value);\n        this.setState({language: event.target.value})\n    }\n\n    setConcat = (event) => {\n        //console.log(event.target.value);\n        this.setState({concat: event.target.checked})\n    }\n\n    render(){\n        return(\n            <div className=\"main\">\n                <h1>\n                    Multiline code statement to just string\n                </h1>\n                <p>I hate removing all quote for getting back the SQL</p>\n                <br/>\n                <div>\n                    Code URL: <a href={this.codeUrl}>{this.codeUrl}</a>\n                </div>\n                <br/><br/>\n\n                <div >\n                    <input type=\"radio\" value=\"java\" name=\"language\" checked={this.state.language === \"java\"} onChange={this.setLanguage}/> Java\n                    <input type=\"radio\" value=\"vb\" name=\"language\" checked={this.state.language === \"vb\"} onChange={this.setLanguage}/> Visual basic\n                    <input type=\"checkbox\" name=\"inv\" checked={this.state.concat} onChange={this.setConcat}/> Concat\n                </div>\n\n                <div className=\"table\">\n                    <div className=\"tr\">\n                        <span className=\"td\"><h3>Input</h3></span>\n                        <span className=\"td\"><h3>Result</h3></span>\n                    </div>\n                    <div className=\"tr\">\n                        <span className=\"td\">\n                            <textarea className=\"taInput\" rows = \"10\" cols = \"80\" name = \"decimal\" value={this.state.input}\n                                onChange={this.handleChange}/>\n                        </span>\n                        <span className=\"td\">\n                            <textarea className=\"taInput\" rows = \"10\" cols = \"80\" name = \"binary\" value={this.state.result} readOnly/>\n                        </span>\n                    </div>\n                </div>\n\n                \n            </div> \n        )\n    }\n}\n\n\nexport default MultiLine;","/*\r\n * jcobyla\r\n * \r\n * The MIT License\r\n *\r\n * Copyright (c) 2012 Anders Gustafsson, Cureos AB.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files \r\n * (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, \r\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, \r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE \r\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n * \r\n * Remarks:\r\n * \r\n * The original Fortran 77 version of this code was by Michael Powell (M.J.D.Powell @ damtp.cam.ac.uk)\r\n * The Fortran 90 version was by Alan Miller (Alan.Miller @ vic.cmis.csiro.au). Latest revision - 30 October 1998\r\n */\r\n\r\n/**\r\n * Constrained Optimization BY Linear Approximation in Java.\r\n * \r\n * COBYLA2 is an implementation of Powell’s nonlinear derivative–free constrained optimization that uses \r\n * a linear approximation approach. The algorithm is a sequential trust–region algorithm that employs linear\r\n * approximations to the objective and constraint functions, where the approximations are formed by linear\r\n * interpolation at n + 1 points in the space of the variables and tries to maintain a regular–shaped simplex \r\n * over iterations.\r\n * \r\n * It solves nonsmooth NLP with a moderate number of variables (about 100). Inequality constraints only.\r\n * \r\n * The initial point X is taken as one vertex of the initial simplex with zero being another, so, X should\r\n * not be entered as the zero vector.\r\n * \r\n * @author Anders Gustafsson, Cureos AB. Translation to Javascript by Reinhard Oldenburg, Goethe-University\r\n */\r\n \r\nfunction arr(n) {var a=new Array(n); for(var i=0; i<n;i++) a[i]=0.0; return a; }\r\nfunction arr2(n,m) {var a= new Array(n); var i=0; while(i<n) {a[i]=arr(m); i=i+1;} return a;}\r\nfunction arraycopy(x, a, iox, b, n) {var i=0; while(i<n) {iox[i+b]=x[i+a];i++;}; }\r\n\r\n// status Variablem\r\nvar Normal=0;\r\nvar MaxIterationsReached=1;\r\nvar DivergingRoundingErrors=2;\r\nvar NoDifferenceInFitness=3;\r\nvar ManuallyStopped=99;\r\nvar Running = -1;\r\n\r\n    /**\r\n     * Minimizes the objective function F with respect to a set of inequality constraints CON,\r\n     * and returns the optimal variable array. F and CON may be non-linear, and should preferably be smooth.\r\n     * \r\n     * @param calcfc Interface implementation for calculating objective function and constraints.\r\n     * @param n Number of variables.\r\n     * @param m Number of constraints.\r\n     * @param x On input initial values of the variables (zero-based array). On output\r\n     * optimal values of the variables obtained in the COBYLA minimization.\r\n     * @param rhobeg Initial size of the simplex.\r\n     * @param rhoend Final value of the simplex.\r\n     * @param iprint Print level, 0 &lt;= iprint &lt;= 3, where 0 provides no output and\r\n     * 3 provides full output to the console.\r\n     * @param maxfun Maximum number of function evaluations before terminating.\r\n     * @param fmaxiter Maximum number of iterations with deviation smaller than fdev in fitness values before termination\r\n     * @return Exit status of the COBYLA2 optimization.\r\n     */\r\n\r\n\t // CobylaExitStatus FindMinimum(final Calcfc calcfc, int n, int m, double[] x, double rhobeg, double rhoend, int iprint, int maxfun)\r\nexport function FindMinimum(calcfc, n,  m, x, rhobeg, rhoend,  iprint,  maxfun, fmaxiter, iterationCallback, callbackIterations)\r\n    {\r\n        //     This subroutine minimizes an objective function F(X) subject to M\r\n        //     inequality constraints on X, where X is a vector of variables that has\r\n        //     N components.  The algorithm employs linear approximations to the\r\n        //     objective and constraint functions, the approximations being formed by\r\n        //     linear interpolation at N+1 points in the space of the variables.\r\n        //     We regard these interpolation points as vertices of a simplex.  The\r\n        //     parameter RHO controls the size of the simplex and it is reduced\r\n        //     automatically from RHOBEG to RHOEND.  For each RHO the subroutine tries\r\n        //     to achieve a good vector of variables for the current size, and then\r\n        //     RHO is reduced until the value RHOEND is reached.  Therefore RHOBEG and\r\n        //     RHOEND should be set to reasonable initial changes to and the required\r\n        //     accuracy in the variables respectively, but this accuracy should be\r\n        //     viewed as a subject for experimentation because it is not guaranteed.\r\n        //     The subroutine has an advantage over many of its competitors, however,\r\n        //     which is that it treats each constraint individually when calculating\r\n        //     a change to the variables, instead of lumping the constraints together\r\n        //     into a single penalty function.  The name of the subroutine is derived\r\n        //     from the phrase Constrained Optimization BY Linear Approximations.\r\n\r\n        //     The user must set the values of N, M, RHOBEG and RHOEND, and must\r\n        //     provide an initial vector of variables in X.  Further, the value of\r\n        //     IPRINT should be set to 0, 1, 2 or 3, which controls the amount of\r\n        //     printing during the calculation. Specifically, there is no output if\r\n        //     IPRINT=0 and there is output only at the end of the calculation if\r\n        //     IPRINT=1.  Otherwise each new value of RHO and SIGMA is printed.\r\n        //     Further, the vector of variables and some function information are\r\n        //     given either when RHO is reduced or when each new value of F(X) is\r\n        //     computed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA\r\n        //     is a penalty parameter, it being assumed that a change to X is an\r\n        //     improvement if it reduces the merit function\r\n        //                F(X)+SIGMA*MAX(0.0, - C1(X), - C2(X),..., - CM(X)),\r\n        //     where C1,C2,...,CM denote the constraint functions that should become\r\n        //     nonnegative eventually, at least to the precision of RHOEND. In the\r\n        //     printed output the displayed term that is multiplied by SIGMA is\r\n        //     called MAXCV, which stands for 'MAXimum Constraint Violation'.  The\r\n        //     argument ITERS is an integer variable that must be set by the user to a\r\n        //     limit on the number of calls of CALCFC, the purpose of this routine being\r\n        //     given below.  The value of ITERS will be altered to the number of calls\r\n        //     of CALCFC that are made.\r\n\r\n        //     In order to define the objective and constraint functions, we require\r\n        //     a subroutine that has the name and arguments\r\n        //                SUBROUTINE CALCFC (N,M,X,F,CON)\r\n        //                DIMENSION X(:),CON(:)  .\r\n        //     The values of N and M are fixed and have been defined already, while\r\n        //     X is now the current vector of variables. The subroutine should return\r\n        //     the objective and constraint functions at X in F and CON(1),CON(2),\r\n        //     ...,CON(M).  Note that we are trying to adjust X so that F(X) is as\r\n        //     small as possible subject to the constraint functions being nonnegative.\r\n        var pleaseStop = false;\r\n        // Local variables\r\n        var mpp = m + 2;\r\n        // Internal base-1 X array\r\n        var iox = arr(n+1);\r\n\t\tiox[0]=0.0;\r\n        arraycopy(x, 0, iox, 1, n);\r\n        // Internal representation of the objective and constraints calculation method, \r\n        // accounting for that X and CON arrays in the cobylb method are base-1 arrays.\r\n        var fcalcfc = function( n, m,  thisx, con)  // int n, int m, double[] x, double[] con\r\n            { \r\n                var ix = arr(n);\r\n                arraycopy(thisx, 1, ix, 0, n);\r\n                var ocon = arr(m);\r\n                var f= calcfc(n, m, ix, ocon);\r\n                arraycopy(ocon, 0, con, 1, m);\r\n                return f; \r\n            }\r\n                     \r\n\r\n        var status = cobylb(fcalcfc, n, m, mpp, iox, rhobeg, rhoend, iprint, maxfun, fmaxiter, iterationCallback, callbackIterations);\r\n        arraycopy(iox, 1, x, 0, n);\r\n\r\n        return status;\r\n    }\r\n    \r\n    // get the difference between the biggest and smallest fitness value of the last \r\n    // <fmaxiter> iterations.\r\n    function getMaxDiffOfFitnessValues(f, fqueue, fmaxiter){\r\n        //add to queue\r\n        fqueue.push(f);\r\n        //if not enough value, can't compute diff\r\n        if(fqueue.length < fmaxiter) \r\n            return Number.MAX_VALUE;\r\n        //remove oldest element\r\n        if(fqueue.length > fmaxiter)\r\n            fqueue.shift();\r\n        //min and max f of last x iterations\r\n        var fmax = Math.max.apply(null, fqueue);\r\n        var fmin = Math.min.apply(null, fqueue);\r\n        \r\n        return (fmax - fmin);\r\n    }\r\n        \r\n//    private static CobylaExitStatus cobylb(Calcfc calcfc, int n, int m, int mpp, double[] x,\r\n  //      double rhobeg, double rhoend, int iprint, int maxfun)\r\n    function cobylb(calcfc, n,  m,  mpp,  x, rhobeg,  rhoend,  iprint,  maxfun, fmaxiter, iterationCallback, callbackIterations)\r\n\t\t// calcf ist funktion die aufgerufen wird wie calcfc(n, m, ix, ocon)\r\n    {\r\n        // N.B. Arguments CON, SIM, SIMI, DATMAT, A, VSIG, VETA, SIGBAR, DX, W & IACT\r\n        //      have been removed.\r\n\r\n        //     Set the initial values of some parameters. The last column of SIM holds\r\n        //     the optimal vertex of the current simplex, and the preceding N columns\r\n        //     hold the displacements from the optimal vertex to the other vertices.\r\n        //     Further, SIMI holds the inverse of the matrix that is contained in the\r\n        //     first N columns of SIM.\r\n\r\n        // Local variables\r\n\r\n        var status=-1;\r\n        \r\n        var alpha = 0.25;\r\n        var beta = 2.1;\r\n        var gamma = 0.5;\r\n        var delta = 1.1;\r\n\r\n        var f = 0.0;\r\n        var fdev = 0.1; //set in UI maybe\r\n        var fqueue = [];\r\n        var resmax = 0.0; \r\n        var total;\r\n\r\n        var np = n + 1;\r\n        var mp = m + 1;\r\n        var rho = rhobeg;\r\n        var parmu = 0.0;\r\n\r\n        var iflag = false;\r\n        var ifull = false;\r\n        var parsig = 0.0;\r\n        var prerec = 0.0;\r\n        var prerem = 0.0;\r\n\r\n        var con = arr(1 + mpp);\r\n        var sim = arr2(1 + n,1 + np);\r\n        var simi = arr2(1 + n,1 + n);\r\n        var datmat = arr2(1 + mpp,1 + np);\r\n        var a = arr2(1 + n,1 + mp);\r\n        var vsig = arr(1 + n);\r\n        var veta = arr(1 + n);\r\n        var sigbar = arr(1 + n);\r\n        var dx = arr(1 + n);\r\n        var w = arr(1 + n);\r\n\r\n        if (iprint >= 2) console.log(\"The initial value of RHO is \"+rho+\" and PARMU is set to zero.\");\r\n\r\n        var nfvals = 0;\r\n        var temp = 1.0 / rho;\r\n\r\n        for (var i = 1; i <= n; ++i)\r\n        {\r\n            sim[i][np] = x[i];\r\n            sim[i][i] = rho;\r\n            simi[i][i] = temp;\r\n        }\r\n\r\n        var jdrop = np;\r\n        var ibrnch = false;\r\n\r\n        //     Make the next call of the user-supplied subroutine CALCFC. These\r\n        //     instructions are also used for calling CALCFC during the iterations of\r\n        //     the algorithm.\r\n        \r\n\t\t//alert(\"Iteration \"+nfvals+\" x=\"+x);\r\n        L_40:\r\n        do\r\n        {\r\n            if (getMaxDiffOfFitnessValues(f, fqueue, fmaxiter) < fdev && nfvals > 0)\r\n            {    \r\n                status = NoDifferenceInFitness;\r\n                break L_40;\r\n            }\r\n            else if (nfvals >= maxfun && nfvals > 0)\r\n            {\r\n                status = MaxIterationsReached;\r\n                break L_40;\r\n            }\r\n\r\n            ++nfvals;\r\n\r\n            f = calcfc(n, m, x, con);\r\n            resmax = 0.0; for (var k = 1; k <= m; ++k) resmax = Math.max(resmax, -con[k]);\r\n//alert(\"   f=\"+f+\"  resmax=\"+resmax);\r\n            if (nfvals == iprint - 1 || iprint == 3)\r\n            {\r\n                PrintIterationResult(nfvals, f, resmax, x, n, iprint);\r\n            }\r\n            if(iterationCallback !== undefined && nfvals % callbackIterations == 0){\r\n              iterationCallback({'status': Running,\r\n                           'statusText': \"Running\",\r\n                           'maxcv': resmax,\r\n                           'fitness': f,\r\n                           'iterations': nfvals,\r\n                           'x': x});\r\n            }\r\n\r\n            con[mp] = f;\r\n            con[mpp] = resmax;\r\n\r\n            //     Set the recently calculated function values in a column of DATMAT. This\r\n            //     array has a column for each vertex of the current simplex, the entries of\r\n            //     each column being the values of the constraint functions (if any)\r\n            //     followed by the objective function and the greatest constraint violation\r\n            //     at the vertex.\r\n\r\n            var skipVertexIdent = true;\r\n            if (!ibrnch)\r\n            {\r\n                skipVertexIdent = false;\r\n                \r\n                for (var i = 1; i <= mpp; ++i) datmat[i][jdrop] = con[i];\r\n\r\n                if (nfvals <= np)\r\n                {\r\n                    //     Exchange the new vertex of the initial simplex with the optimal vertex if\r\n                    //     necessary. Then, if the initial simplex is not complete, pick its next\r\n                    //     vertex and calculate the function values there.\r\n\r\n                    if (jdrop <= n)\r\n                    {\r\n                        if (datmat[mp][np] <= f)\r\n                        {\r\n                            x[jdrop] = sim[jdrop][np];\r\n                        }\r\n                        else\r\n                        {\r\n                            sim[jdrop][np] = x[jdrop];\r\n                            for (var k = 1; k <= mpp; ++k)\r\n                            {\r\n                                datmat[k][jdrop] = datmat[k][np];\r\n                                datmat[k][np] = con[k];\r\n                            }\r\n                            for (var k = 1; k <= jdrop; ++k)\r\n                            {\r\n                                sim[jdrop][k] = -rho;\r\n                                temp = 0.0; for (var i = k; i <= jdrop; ++i) temp -= simi[i][k];\r\n                                simi[jdrop][k] = temp;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (nfvals <= n)\r\n                    {\r\n                        jdrop = nfvals;\r\n                        x[jdrop] += rho;\r\n                        continue L_40;\r\n                    }\r\n                }\r\n\r\n                ibrnch = true;\r\n            }\r\n            \r\n            L_140:\r\n            do\r\n            {\r\n                L_550:\r\n                do\r\n                {\r\n                    if (!skipVertexIdent)\r\n                    {\r\n                        //     Identify the optimal vertex of the current simplex.\r\n\r\n                        var phimin = datmat[mp][np] + parmu * datmat[mpp][np];\r\n                        var nbest = np;\r\n\r\n                        for (var j = 1; j <= n; ++j)\r\n                        {\r\n                            temp = datmat[mp][j] + parmu * datmat[mpp][j];\r\n                            if (temp < phimin)\r\n                            {\r\n                                nbest = j;\r\n                                phimin = temp;\r\n                            }\r\n                            else if (temp == phimin && parmu == 0.0 && datmat[mpp][j] < datmat[mpp][nbest])\r\n                            {\r\n                                nbest = j;\r\n                            }\r\n                        }\r\n\r\n                        //     Switch the best vertex into pole position if it is not there already,\r\n                        //     and also update SIM, SIMI and DATMAT.\r\n\r\n                        if (nbest <= n)\r\n                        {\r\n                            for (var i = 1; i <= mpp; ++i)\r\n                            {\r\n                                temp = datmat[i][np];\r\n                                datmat[i][np] = datmat[i][nbest];\r\n                                datmat[i][nbest] = temp;\r\n                            }\r\n                            for (var i = 1; i <= n; ++i)\r\n                            {\r\n                                temp = sim[i][nbest];\r\n                                sim[i][nbest] = 0.0;\r\n                                sim[i][np] += temp;\r\n\r\n                                var tempa = 0.0;\r\n                                for (var k = 1; k <= n; ++k)\r\n                                {\r\n                                    sim[i][k] -= temp;\r\n                                    tempa -= simi[k][i];\r\n                                }\r\n                                simi[nbest][i] = tempa;\r\n                            }\r\n                        }\r\n\r\n                        //     Make an error return if SIGI is a poor approximation to the inverse of\r\n                        //     the leading N by N submatrix of SIG.\r\n\r\n                        var error = 0.0;\r\n                        for (var i = 1; i <= n; ++i)\r\n                        {\r\n                            for (var j = 1; j <= n; ++j)\r\n                            {\r\n                                temp = DOT_PRODUCT(PART(ROW(simi, i), 1, n), PART(COL(sim, j), 1, n)) - (i == j ? 1.0 : 0.0);\r\n                                error = Math.max(error, Math.abs(temp));\r\n                            }\r\n                        }\r\n                        if (error > 0.1)\r\n                        {\r\n                            status = DivergingRoundingErrors;\r\n                            break L_40;\r\n                        }\r\n\r\n                        //     Calculate the coefficients of the linear approximations to the objective\r\n                        //     and constraint functions, placing minus the objective function gradient\r\n                        //     after the constraint gradients in the array A. The vector W is used for\r\n                        //     working space.\r\n\r\n                        for (var k = 1; k <= mp; ++k)\r\n                        {\r\n                            con[k] = -datmat[k][np];\r\n                            for (var j = 1; j <= n; ++j) w[j] = datmat[k][j] + con[k];\r\n\r\n                            for (var i = 1; i <= n; ++i)\r\n                            {\r\n                                a[i][k] = (k == mp ? -1.0 : 1.0) * DOT_PRODUCT(PART(w, 1, n), PART(COL(simi, i), 1, n));\r\n                            }\r\n                        }\r\n\r\n                        //     Calculate the values of sigma and eta, and set IFLAG = 0 if the current\r\n                        //     simplex is not acceptable.\r\n\r\n                        iflag = true;\r\n                        parsig = alpha * rho;\r\n                        var pareta = beta * rho;\r\n\r\n                        for (var j = 1; j <= n; ++j)\r\n                        {\r\n                            var wsig = 0.0; for (var k = 1; k <= n; ++k) wsig += simi[j][k] * simi[j][k];\r\n                            var weta = 0.0; for (var k = 1; k <= n; ++k) weta += sim[k][j] * sim[k][j];\r\n                            vsig[j] = 1.0 / Math.sqrt(wsig);\r\n                            veta[j] = Math.sqrt(weta);\r\n                            if (vsig[j] < parsig || veta[j] > pareta) iflag = false;\r\n                        }\r\n\r\n                        //     If a new vertex is needed to improve acceptability, then decide which\r\n                        //     vertex to drop from the simplex.\r\n\r\n                        if (!ibrnch && !iflag)\r\n                        {\r\n                            jdrop = 0;\r\n                            temp = pareta;\r\n                            for (var j = 1; j <= n; ++j)\r\n                            {\r\n                                if (veta[j] > temp)\r\n                                {\r\n                                    jdrop = j;\r\n                                    temp = veta[j];\r\n                                }\r\n                            }\r\n                            if (jdrop == 0)\r\n                            {\r\n                                for (var j = 1; j <= n; ++j)\r\n                                {\r\n                                    if (vsig[j] < temp)\r\n                                    {\r\n                                        jdrop = j;\r\n                                        temp = vsig[j];\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            //     Calculate the step to the new vertex and its sign.\r\n\r\n                            temp = gamma * rho * vsig[jdrop];\r\n                            for (var k = 1; k <= n; ++k) dx[k] = temp * simi[jdrop][k];\r\n                            var cvmaxp = 0.0;\r\n                            var cvmaxm = 0.0;\r\n\r\n                            total = 0.0;\r\n                            for (var k = 1; k <= mp; ++k)\r\n                            {\r\n                                total = DOT_PRODUCT(PART(COL(a, k), 1, n), PART(dx, 1, n));\r\n                                if (k < mp)\r\n                                {\r\n                                    temp = datmat[k][np];\r\n                                    cvmaxp = Math.max(cvmaxp, -total - temp);\r\n                                    cvmaxm = Math.max(cvmaxm, total - temp);\r\n                                }\r\n                            }\r\n                            var dxsign = parmu * (cvmaxp - cvmaxm) > 2.0 * total ? -1.0 : 1.0;\r\n\r\n                            //     Update the elements of SIM and SIMI, and set the next X.\r\n\r\n                            temp = 0.0;\r\n                            for (var i = 1; i <= n; ++i)\r\n                            {\r\n                                dx[i] = dxsign * dx[i];\r\n                                sim[i][jdrop] = dx[i];\r\n                                temp += simi[jdrop][i] * dx[i];\r\n                            }\r\n                            for (var k = 1; k <= n; ++k) simi[jdrop][k] /= temp;\r\n\r\n                            for (var j = 1; j <= n; ++j)\r\n                            {\r\n                                if (j != jdrop)\r\n                                {\r\n                                    temp = DOT_PRODUCT(PART(ROW(simi, j), 1, n), PART(dx, 1, n));\r\n                                    for (var k = 1; k <= n; ++k) simi[j][k] -= temp * simi[jdrop][k];\r\n                                }\r\n                                x[j] = sim[j][np] + dx[j];\r\n                            }\r\n                            continue L_40;\r\n                        }\r\n\r\n                        //     Calculate DX = x(*)-x(0).\r\n                        //     Branch if the length of DX is less than 0.5*RHO.\r\n\r\n                        ifull = trstlp(n, m, a, con, rho, dx);\r\n                        if (!ifull)\r\n                        {\r\n                            temp = 0.0; for (var k = 1; k <= n; ++k) temp += dx[k] * dx[k];\r\n                            if (temp < 0.25 * rho * rho)\r\n                            {\r\n                                ibrnch = true;\r\n                                break L_550;\r\n                            }\r\n                        }\r\n\r\n                        //     Predict the change to F and the new maximum constravar violation if the\r\n                        //     variables are altered from x(0) to x(0) + DX.\r\n\r\n                        total = 0.0;\r\n                        var resnew = 0.0;\r\n                        con[mp] = 0.0;\r\n                        for (var k = 1; k <= mp; ++k)\r\n                        {\r\n                            total = con[k] - DOT_PRODUCT(PART(COL(a, k), 1, n), PART(dx, 1, n));\r\n                            if (k < mp) resnew = Math.max(resnew, total);\r\n                        }\r\n\r\n                        //     Increase PARMU if necessary and branch back if this change alters the\r\n                        //     optimal vertex. Otherwise PREREM and PREREC will be set to the predicted\r\n                        //     reductions in the merit function and the maximum constraint violation\r\n                        //     respectively.\r\n\r\n                        prerec = datmat[mpp][np] - resnew;\r\n                        var barmu = prerec > 0.0 ? total / prerec : 0.0;\r\n                        if (parmu < 1.5 * barmu)\r\n                        {\r\n                            parmu = 2.0 * barmu;\r\n                            if (iprint >= 2) console.log(\"Increase in PARMU to \"+parmu);\r\n                            var phi = datmat[mp][np] + parmu * datmat[mpp][np];\r\n                            for (var j = 1; j <= n; ++j)\r\n                            {\r\n                                temp = datmat[mp][j] + parmu * datmat[mpp][j];\r\n                                if (temp < phi || (temp == phi && parmu == 0.0 && datmat[mpp][j] < datmat[mpp][np])) continue L_140;\r\n                            }\r\n                        }\r\n                        prerem = parmu * prerec - total;\r\n\r\n                        //     Calculate the constraint and objective functions at x(*).\r\n                        //     Then find the actual reduction in the merit function.\r\n\r\n                        for (var k = 1; k <= n; ++k) x[k] = sim[k][np] + dx[k];\r\n                        ibrnch = true;\r\n                        continue L_40;\r\n                    }\r\n\r\n                    skipVertexIdent = false;\r\n                    var vmold = datmat[mp][np] + parmu * datmat[mpp][np];\r\n                    var vmnew = f + parmu * resmax;\r\n                    var trured = vmold - vmnew;\r\n                    if (parmu == 0.0 && f == datmat[mp][np])\r\n                    {\r\n                        prerem = prerec;\r\n                        trured = datmat[mpp][np] - resmax;\r\n                    }\r\n\r\n                    //     Begin the operations that decide whether x(*) should replace one of the\r\n                    //     vertices of the current simplex, the change being mandatory if TRURED is\r\n                    //     positive. Firstly, JDROP is set to the index of the vertex that is to be\r\n                    //     replaced.\r\n\r\n                    var ratio = trured <= 0.0 ? 1.0 : 0.0;\r\n                    jdrop = 0;\r\n                    for (var j = 1; j <= n; ++j)\r\n                    {\r\n                        temp = Math.abs(DOT_PRODUCT(PART(ROW(simi, j), 1, n), PART(dx, 1, n)));\r\n                        if (temp > ratio)\r\n                        {\r\n                            jdrop = j;\r\n                            ratio = temp;\r\n                        }\r\n                        sigbar[j] = temp * vsig[j];\r\n                    }\r\n\r\n                    //     Calculate the value of ell.\r\n\r\n                    var edgmax = delta * rho;\r\n                    var l = 0;\r\n                    for (var j = 1; j <= n; ++j)\r\n                    {\r\n                        if (sigbar[j] >= parsig || sigbar[j] >= vsig[j])\r\n                        {\r\n                            temp = veta[j];\r\n                            if (trured > 0.0)\r\n                            {\r\n                                temp = 0.0; for (var k = 1; k <= n; ++k) temp += Math.pow(dx[k] - sim[k][j], 2.0);\r\n                                temp = Math.sqrt(temp);\r\n                            }\r\n                            if (temp > edgmax)\r\n                            {\r\n                                l = j;\r\n                                edgmax = temp;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (l > 0) jdrop = l;\r\n\r\n                    if (jdrop != 0)\r\n                    {\r\n                        //     Revise the simplex by updating the elements of SIM, SIMI and DATMAT.\r\n\r\n                        temp = 0.0;\r\n                        for (var i = 1; i <= n; ++i)\r\n                        {\r\n                            sim[i][jdrop] = dx[i];\r\n                            temp += simi[jdrop][i] * dx[i];\r\n                        }\r\n                        for (var k = 1; k <= n; ++k) simi[jdrop][k] /= temp;\r\n                        for (var j = 1; j <= n; ++j)\r\n                        {\r\n                            if (j != jdrop)\r\n                            {\r\n                                temp = DOT_PRODUCT(PART(ROW(simi, j), 1, n), PART(dx, 1, n));\r\n                                for (var k = 1; k <= n; ++k) simi[j][k] -= temp * simi[jdrop][k];\r\n                            }\r\n                        }\r\n                        for (var k = 1; k <= mpp; ++k) datmat[k][jdrop] = con[k];\r\n\r\n                        //     Branch back for further iterations with the current RHO.\r\n\r\n                        if (trured > 0.0 && trured >= 0.1 * prerem) continue L_140;\r\n                    }\r\n                } while (false);\r\n                \r\n                if (!iflag)\r\n                {\r\n                    ibrnch = false;\r\n                    continue L_140;\r\n                }\r\n\r\n                if (rho <= rhoend)\r\n                {\r\n                    status = Normal;\r\n                    break L_40;\r\n                }\r\n\r\n                //     Otherwise reduce RHO if it is not at its least value and reset PARMU.\r\n\r\n                var cmin = 0.0, cmax = 0.0;\r\n\r\n                rho *= 0.5;\r\n                if (rho <= 1.5 * rhoend) rho = rhoend;\r\n                if (parmu > 0.0)\r\n                {\r\n                    var denom = 0.0;\r\n                    for (var k = 1; k <= mp; ++k)\r\n                    {\r\n                        cmin = datmat[k][np];\r\n                        cmax = cmin;\r\n                        for (var i = 1; i <= n; ++i)\r\n                        {\r\n                            cmin = Math.min(cmin, datmat[k][i]);\r\n                            cmax = Math.max(cmax, datmat[k][i]);\r\n                        }\r\n                        if (k <= m && cmin < 0.5 * cmax)\r\n                        {\r\n                            temp = Math.max(cmax, 0.0) - cmin;\r\n                            denom = denom <= 0.0 ? temp : Math.min(denom, temp);\r\n                        }\r\n                    }\r\n                    if (denom == 0.0)\r\n                    {\r\n                        parmu = 0.0;\r\n                    }\r\n                    else if (cmax - cmin < parmu * denom)\r\n                    {\r\n                        parmu = (cmax - cmin) / denom;\r\n                    }\r\n                }\r\n                if (iprint >= 2)\r\n                    console.log(\"Reduction in RHO to \"+rho+\"  and PARMU = \"+parmu);\r\n                if (iprint == 2) \r\n                    PrintIterationResult(nfvals, datmat[mp][np], datmat[mpp][np], COL(sim, np), n, iprint);\r\n\r\n            } while (true);\r\n            \r\n        } while (true);\r\n        \r\n        switch (status)\r\n        {\r\n            case Normal:\r\n                if (iprint >= 1) console.log(\"%nNormal return from subroutine COBYLA%n\");\r\n                if (ifull)\r\n                {\r\n                    if (iprint >= 1) PrintIterationResult(nfvals, f, resmax, x, n, iprint);\r\n                    return status;\r\n                }\r\n                break;\r\n            case MaxIterationsReached:\r\n                if (iprint >= 1)\r\n                    console.log(\"%nReturn from subroutine COBYLA because the MAXFUN limit has been reached.%n\");\r\n                break;\r\n            case DivergingRoundingErrors:\r\n                if (iprint >= 1)\r\n                    console.log(\"%nReturn from subroutine COBYLA because rounding errors are becoming damaging.%n\");\r\n                break;\r\n            case NoDifferenceInFitness:\r\n                if (iprint >= 1)\r\n                    console.log(\"%nReturn from subroutine COBYLA because no difference in fitness after \"+fmaxiter+\" iterations detected.%n\");\r\n                break;\r\n            case ManuallyStopped:\r\n                if (iprint >= 1)\r\n                    console.log(\"%nReturn from subroutine COBYLA because user asked us to.%n\");\r\n                break;\r\n        }\r\n        \r\n        for (var k = 1; k <= n; ++k) x[k] = sim[k][np];\r\n        f = datmat[mp][np];\r\n        resmax = datmat[mpp][np];\r\n        if (iprint >= 1) PrintIterationResult(nfvals, f, resmax, x, n, iprint);\r\n        \r\n        return {status: status,\r\n                statusText: [\"Normal\", \"MaxIterationsReached\", \"DivergingRoundingErrors\", \"NoDifferenceInFitness\",\"Cancelled\"][status],\r\n                maxcv: resmax,\r\n                fitness: f,\r\n                iterations: nfvals,\r\n                x: x};\r\n    }\r\n\r\n    function trstlp(n,  m,  a, b, rho,  dx) //(int n, int m, double[][] a, double[] b, double rho, double[] dx)\r\n    {\r\n        // N.B. Arguments Z, ZDOTA, VMULTC, SDIRN, DXNEW, VMULTD & IACT have been removed.\r\n\r\n        //     This subroutine calculates an N-component vector DX by applying the\r\n        //     following two stages. In the first stage, DX is set to the shortest\r\n        //     vector that minimizes the greatest violation of the constraints\r\n        //       A(1,K)*DX(1)+A(2,K)*DX(2)+...+A(N,K)*DX(N) .GE. B(K), K = 2,3,...,M,\r\n        //     subject to the Euclidean length of DX being at most RHO. If its length is\r\n        //     strictly less than RHO, then we use the resultant freedom in DX to\r\n        //     minimize the objective function\r\n        //              -A(1,M+1)*DX(1) - A(2,M+1)*DX(2) - ... - A(N,M+1)*DX(N)\r\n        //     subject to no increase in any greatest constraint violation. This\r\n        //     notation allows the gradient of the objective function to be regarded as\r\n        //     the gradient of a constraint. Therefore the two stages are distinguished\r\n        //     by MCON .EQ. M and MCON .GT. M respectively. It is possible that a\r\n        //     degeneracy may prevent DX from attaining the target length RHO. Then the\r\n        //     value IFULL = 0 would be set, but usually IFULL = 1 on return.\r\n\r\n        //     In general NACT is the number of constraints in the active set and\r\n        //     IACT(1),...,IACT(NACT) are their indices, while the remainder of IACT\r\n        //     contains a permutation of the remaining constraint indices.  Further, Z\r\n        //     is an orthogonal matrix whose first NACT columns can be regarded as the\r\n        //     result of Gram-Schmidt applied to the active constraint gradients.  For\r\n        //     J = 1,2,...,NACT, the number ZDOTA(J) is the scalar product of the J-th\r\n        //     column of Z with the gradient of the J-th active constraint.  DX is the\r\n        //     current vector of variables and here the residuals of the active\r\n        //     constraints should be zero. Further, the active constraints have\r\n        //     nonnegative Lagrange multipliers that are held at the beginning of\r\n        //     VMULTC. The remainder of this vector holds the residuals of the inactive\r\n        //     constraints at DX, the ordering of the components of VMULTC being in\r\n        //     agreement with the permutation of the indices of the constraints that is\r\n        //     in IACT. All these residuals are nonnegative, which is achieved by the\r\n        //     shift RESMAX that makes the least residual zero.\r\n\r\n        //     Initialize Z and some other variables. The value of RESMAX will be\r\n        //     appropriate to DX = 0, while ICON will be the index of a most violated\r\n        //     constraint if RESMAX is positive. Usually during the first stage the\r\n        //     vector SDIRN gives a search direction that reduces all the active\r\n        //     constraint violations by one simultaneously.\r\n\r\n        // Local variables\r\n\r\n        var temp=0;\r\n\r\n        var nactx = 0;\r\n        var resold = 0.0;\r\n\r\n        var z = arr2(1 + n,1 + n);\r\n        var zdota = arr(2 + m);\r\n        var vmultc = arr(2 + m);\r\n        var sdirn = arr(1 + n);\r\n        var dxnew = arr(1 + n);\r\n        var vmultd = arr(2 + m);\r\n        var iact = arr(2 + m);\r\n\r\n        var mcon = m;\r\n        var nact = 0;\r\n        for (var i = 1; i <= n; ++i)\r\n        {\r\n            z[i][i] = 1.0;\r\n            dx[i] = 0.0;\r\n        }\r\n\r\n        var icon = 0;\r\n        var resmax = 0.0;\r\n        if (m >= 1)\r\n        {\r\n            for (var k = 1; k <= m; ++k)\r\n            {\r\n                if (b[k] > resmax)\r\n                {\r\n                    resmax = b[k];\r\n                    icon = k;\r\n                }\r\n            }\r\n            for (var k = 1; k <= m; ++k)\r\n            {\r\n                iact[k] = k;\r\n                vmultc[k] = resmax - b[k];\r\n            }\r\n        }\r\n        \r\n        //     End the current stage of the calculation if 3 consecutive iterations\r\n        //     have either failed to reduce the best calculated value of the objective\r\n        //     function or to increase the number of active constraints since the best\r\n        //     value was calculated. This strategy prevents cycling, but there is a\r\n        //     remote possibility that it will cause premature termination.\r\n\r\n        var first = true;\r\n        do\r\n        {\r\n            L_60:\r\n            do\r\n            {\r\n                if (!first || (first && resmax == 0.0))\r\n                {\r\n                    mcon = m + 1;\r\n                    icon = mcon;\r\n                    iact[mcon] = mcon;\r\n                    vmultc[mcon] = 0.0;\r\n                }\r\n                first = false;\r\n\r\n                var optold = 0.0;\r\n                var icount = 0;\r\n\r\n                var step=0, stpful=0;\r\n                \r\n                L_70:\r\n                do\r\n                {\r\n                    var optnew = mcon == m ? resmax : -DOT_PRODUCT(PART(dx, 1, n), PART(COL(a, mcon), 1, n));\r\n\r\n                    if (icount == 0 || optnew < optold)\r\n                    {\r\n                        optold = optnew;\r\n                        nactx = nact;\r\n                        icount = 3;\r\n                    }\r\n                    else if (nact > nactx)\r\n                    {\r\n                        nactx = nact;\r\n                        icount = 3;\r\n                    }\r\n                    else\r\n                    {\r\n                        --icount;\r\n                    }\r\n                    if (icount == 0) break L_60;\r\n\r\n                    //     If ICON exceeds NACT, then we add the constraint with index IACT(ICON) to\r\n                    //     the active set. Apply Givens rotations so that the last N-NACT-1 columns\r\n                    //     of Z are orthogonal to the gradient of the new constraint, a scalar\r\n                    //     product being set to zero if its nonzero value could be due to computer\r\n                    //     rounding errors. The array DXNEW is used for working space.\r\n\r\n                    var ratio=0;\r\n                    if (icon <= nact)\r\n                    {\r\n                        if (icon < nact)\r\n                        {\r\n                            //     Delete the constraint that has the index IACT(ICON) from the active set.\r\n\r\n                            var isave = iact[icon];\r\n                            var vsave = vmultc[icon];\r\n                            var k = icon;\r\n                            do\r\n                            {\r\n                                var kp = k + 1;\r\n                                var kk = iact[kp];\r\n                                var sp = DOT_PRODUCT(PART(COL(z, k), 1, n), PART(COL(a, kk), 1, n));\r\n                                temp = Math.sqrt(sp * sp + zdota[kp] * zdota[kp]);\r\n                                var alpha = zdota[kp] / temp;\r\n                                var beta = sp / temp;\r\n                                zdota[kp] = alpha * zdota[k];\r\n                                zdota[k] = temp;\r\n                                for (var i = 1; i <= n; ++i)\r\n                                {\r\n                                    temp = alpha * z[i][kp] + beta * z[i][k];\r\n                                    z[i][kp] = alpha * z[i][k] - beta * z[i][kp];\r\n                                    z[i][k] = temp;\r\n                                }\r\n                                iact[k] = kk;\r\n                                vmultc[k] = vmultc[kp];\r\n                                k = kp;\r\n                            } while (k < nact);\r\n\r\n                            iact[k] = isave;\r\n                            vmultc[k] = vsave;\r\n                        }\r\n                        --nact;\r\n\r\n                        //     If stage one is in progress, then set SDIRN to the direction of the next\r\n                        //     change to the current vector of variables.\r\n\r\n                        if (mcon > m)\r\n                        {\r\n                            //     Pick the next search direction of stage two.\r\n\r\n                            temp = 1.0 / zdota[nact];\r\n                            for (var k = 1; k <= n; ++k) sdirn[k] = temp * z[k][nact];\r\n                        }\r\n                        else\r\n                        {\r\n                            temp = DOT_PRODUCT(PART(sdirn, 1, n), PART(COL(z, nact + 1), 1, n));\r\n                            for (var k = 1; k <= n; ++k) sdirn[k] -= temp * z[k][nact + 1];\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        var kk = iact[icon];\r\n                        for (var k = 1; k <= n; ++k) dxnew[k] = a[k][kk];\r\n                        var tot = 0.0;\r\n\r\n                        {\r\n                            var k = n;\r\n                            while (k > nact)\r\n                            {\r\n                                var sp = 0.0;\r\n                                var spabs = 0.0;\r\n                                for (var i = 1; i <= n; ++i)\r\n                                {\r\n                                    temp = z[i][k] * dxnew[i];\r\n                                    sp += temp;\r\n                                    spabs += Math.abs(temp);\r\n                                }\r\n                                var acca = spabs + 0.1 * Math.abs(sp);\r\n                                var accb = spabs + 0.2 * Math.abs(sp);\r\n                                if (spabs >= acca || acca >= accb) sp = 0.0;\r\n                                if (tot == 0.0)\r\n                                {\r\n                                    tot = sp;\r\n                                }\r\n                                else\r\n                                {\r\n                                    var kp = k + 1;\r\n                                    temp = Math.sqrt(sp * sp + tot * tot);\r\n                                    var alpha = sp / temp;\r\n                                    var beta = tot / temp;\r\n                                    tot = temp;\r\n                                    for (var i = 1; i <= n; ++i)\r\n                                    {\r\n                                        temp = alpha * z[i][k] + beta * z[i][kp];\r\n                                        z[i][kp] = alpha * z[i][kp] - beta * z[i][k];\r\n                                        z[i][k] = temp;\r\n                                    }\r\n                                }\r\n                                --k;\r\n                            }\r\n                        }\r\n\r\n                        if (tot == 0.0)\r\n                        {\r\n                            //     The next instruction is reached if a deletion has to be made from the\r\n                            //     active set in order to make room for the new active constraint, because\r\n                            //     the new constraint gradient is a linear combination of the gradients of\r\n                            //     the old active constraints.  Set the elements of VMULTD to the multipliers\r\n                            //     of the linear combination.  Further, set IOUT to the index of the\r\n                            //     constraint to be deleted, but branch if no suitable index can be found.\r\n\r\n                            ratio = -1.0;\r\n                            {\r\n                                var k = nact;\r\n                                do\r\n                                {\r\n                                    var zdotv = 0.0;\r\n                                    var zdvabs = 0.0;\r\n\r\n                                    for (var i = 1; i <= n; ++i)\r\n                                    {\r\n                                        temp = z[i][k] * dxnew[i];\r\n                                        zdotv += temp;\r\n                                        zdvabs += Math.abs(temp);\r\n                                    }\r\n                                    var acca = zdvabs + 0.1 * Math.abs(zdotv);\r\n                                    var accb = zdvabs + 0.2 * Math.abs(zdotv);\r\n                                    if (zdvabs < acca && acca < accb)\r\n                                    {\r\n                                        temp = zdotv / zdota[k];\r\n                                        if (temp > 0.0 && iact[k] <= m)\r\n                                        {\r\n                                            var tempa = vmultc[k] / temp;\r\n                                            if (ratio < 0.0 || tempa < ratio) ratio = tempa;\r\n                                        }\r\n\r\n                                        if (k >= 2)\r\n                                        {\r\n                                            var kw = iact[k];\r\n                                            for (var i = 1; i <= n; ++i) dxnew[i] -= temp * a[i][kw];\r\n                                        }\r\n                                        vmultd[k] = temp;\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        vmultd[k] = 0.0;\r\n                                    }\r\n                                } while (--k > 0);\r\n                            }\r\n                            if (ratio < 0.0) break L_60;\r\n\r\n                            //     Revise the Lagrange multipliers and reorder the active constraints so\r\n                            //     that the one to be replaced is at the end of the list. Also calculate the\r\n                            //     new value of ZDOTA(NACT) and branch if it is not acceptable.\r\n\r\n                            for (var k = 1; k <= nact; ++k)\r\n                                vmultc[k] = Math.max(0.0, vmultc[k] - ratio * vmultd[k]);\r\n                            if (icon < nact)\r\n                            {\r\n                                var isave = iact[icon];\r\n                                var vsave = vmultc[icon];\r\n                                var k = icon;\r\n                                do\r\n                                {\r\n                                    var kp = k + 1;\r\n                                    var kw = iact[kp];\r\n                                    var sp = DOT_PRODUCT(PART(COL(z, k), 1, n), PART(COL(a, kw), 1, n));\r\n                                    temp = Math.sqrt(sp * sp + zdota[kp] * zdota[kp]);\r\n                                    var alpha = zdota[kp] / temp;\r\n                                    var beta = sp / temp;\r\n                                    zdota[kp] = alpha * zdota[k];\r\n                                    zdota[k] = temp;\r\n                                    for (var i = 1; i <= n; ++i)\r\n                                    {\r\n                                        temp = alpha * z[i][kp] + beta * z[i][k];\r\n                                        z[i][kp] = alpha * z[i][k] - beta * z[i][kp];\r\n                                        z[i][k] = temp;\r\n                                    }\r\n                                    iact[k] = kw;\r\n                                    vmultc[k] = vmultc[kp];\r\n                                    k = kp;\r\n                                } while (k < nact);\r\n                                iact[k] = isave;\r\n                                vmultc[k] = vsave;\r\n                            }\r\n                            temp = DOT_PRODUCT(PART(COL(z, nact), 1, n), PART(COL(a, kk), 1, n));\r\n                            if (temp == 0.0) break L_60;\r\n                            zdota[nact] = temp;\r\n                            vmultc[icon] = 0.0;\r\n                            vmultc[nact] = ratio;\r\n                        }\r\n                        else\r\n                        {\r\n                            //     Add the new constraint if this can be done without a deletion from the\r\n                            //     active set.\r\n\r\n                            ++nact;\r\n                            zdota[nact] = tot;\r\n                            vmultc[icon] = vmultc[nact];\r\n                            vmultc[nact] = 0.0;\r\n                        }\r\n                        \r\n                        //     Update IACT and ensure that the objective function continues to be\r\n                        //     treated as the last active constraint when MCON>M.\r\n\r\n                        iact[icon] = iact[nact];\r\n                        iact[nact] = kk;\r\n                        if (mcon > m && kk != mcon)\r\n                        {\r\n                            var k = nact - 1;\r\n                            var sp = DOT_PRODUCT(PART(COL(z, k), 1, n), PART(COL(a, kk), 1, n));\r\n                            temp = Math.sqrt(sp * sp + zdota[nact] * zdota[nact]);\r\n                            var alpha = zdota[nact] / temp;\r\n                            var beta = sp / temp;\r\n                            zdota[nact] = alpha * zdota[k];\r\n                            zdota[k] = temp;\r\n                            for (var i = 1; i <= n; ++i)\r\n                            {\r\n                                temp = alpha * z[i][nact] + beta * z[i][k];\r\n                                z[i][nact] = alpha * z[i][k] - beta * z[i][nact];\r\n                                z[i][k] = temp;\r\n                            }\r\n                            iact[nact] = iact[k];\r\n                            iact[k] = kk;\r\n                            temp = vmultc[k];\r\n                            vmultc[k] = vmultc[nact];\r\n                            vmultc[nact] = temp;\r\n                        }\r\n\r\n                        //     If stage one is in progress, then set SDIRN to the direction of the next\r\n                        //     change to the current vector of variables.\r\n\r\n                        if (mcon > m)\r\n                        {\r\n                            //     Pick the next search direction of stage two.\r\n\r\n                            temp = 1.0 / zdota[nact];\r\n                            for (var k = 1; k <= n; ++k) sdirn[k] = temp * z[k][nact];                            \r\n                        }\r\n                        else\r\n                        {\r\n                            kk = iact[nact];\r\n                            temp = (DOT_PRODUCT(PART(sdirn, 1, n), PART(COL(a, kk), 1, n)) - 1.0) / zdota[nact];\r\n                            for (var k = 1; k <= n; ++k) sdirn[k] -= temp * z[k][nact];\r\n                        }\r\n                    }\r\n                    \r\n                    //     Calculate the step to the boundary of the trust region or take the step\r\n                    //     that reduces RESMAX to zero. The two statements below that include the\r\n                    //     factor 1.0E-6 prevent some harmless underflows that occurred in a test\r\n                    //     calculation. Further, we skip the step if it could be zero within a\r\n                    //     reasonable tolerance for computer rounding errors.\r\n\r\n                    var dd = rho * rho;\r\n                    var sd = 0.0;\r\n                    var ss = 0.0;\r\n                    for (var i = 1; i <= n; ++i)\r\n                    {\r\n                        if (Math.abs(dx[i]) >= 1.0E-6 * rho) dd -= dx[i] * dx[i];\r\n                        sd += dx[i] * sdirn[i];\r\n                        ss += sdirn[i] * sdirn[i];\r\n                    }\r\n                    if (dd <= 0.0) break L_60;\r\n                    temp = Math.sqrt(ss * dd);\r\n                    if (Math.abs(sd) >= 1.0E-6 * temp) temp = Math.sqrt(ss * dd + sd * sd);\r\n                    stpful = dd / (temp + sd);\r\n                    step = stpful;\r\n                    if (mcon == m)\r\n                    {\r\n                        var acca = step + 0.1 * resmax;\r\n                        var accb = step + 0.2 * resmax;\r\n                        if (step >= acca || acca >= accb) break L_70;\r\n                        step = Math.min(step, resmax);\r\n                    }\r\n\r\n                    //     Set DXNEW to the new variables if STEP is the steplength, and reduce\r\n                    //     RESMAX to the corresponding maximum residual if stage one is being done.\r\n                    //     Because DXNEW will be changed during the calculation of some Lagrange\r\n                    //     multipliers, it will be restored to the following value later.\r\n\r\n                    for (var k = 1; k <= n; ++k) dxnew[k] = dx[k] + step * sdirn[k];\r\n                    if (mcon == m)\r\n                    {\r\n                        resold = resmax;\r\n                        resmax = 0.0;\r\n                        for (var k = 1; k <= nact; ++k)\r\n                        {\r\n                            var kk = iact[k];\r\n                            temp = b[kk] - DOT_PRODUCT(PART(COL(a, kk), 1, n), PART(dxnew, 1, n));\r\n                            resmax = Math.max(resmax, temp);\r\n                        }\r\n                    }\r\n\r\n                    //     Set VMULTD to the VMULTC vector that would occur if DX became DXNEW. A\r\n                    //     device is included to force VMULTD(K) = 0.0 if deviations from this value\r\n                    //     can be attributed to computer rounding errors. First calculate the new\r\n                    //     Lagrange multipliers.\r\n\r\n                    {\r\n                        var k = nact;            \r\n                        do\r\n                        {\r\n                            var zdotw = 0.0;\r\n                            var zdwabs = 0.0;\r\n                            for (var i = 1; i <= n; ++i)\r\n                            {\r\n                                temp = z[i][k] * dxnew[i];\r\n                                zdotw += temp;\r\n                                zdwabs += Math.abs(temp);\r\n                            }\r\n                            var acca = zdwabs + 0.1 * Math.abs(zdotw);\r\n                            var accb = zdwabs + 0.2 * Math.abs(zdotw);\r\n                            if (zdwabs >= acca || acca >= accb) zdotw = 0.0;\r\n                            vmultd[k] = zdotw / zdota[k];\r\n                            if (k >= 2)\r\n                            {\r\n                                var kk = iact[k];\r\n                                for (var i = 1; i <= n; ++i) dxnew[i] -= vmultd[k] * a[i][kk];\r\n                            }\r\n                        } while (k-- >= 2);\r\n                        if (mcon > m) vmultd[nact] = Math.max(0.0, vmultd[nact]);\r\n                    }\r\n\r\n                    //     Complete VMULTC by finding the new constraint residuals.\r\n\r\n                    for (var k = 1; k <= n; ++k) dxnew[k] = dx[k] + step * sdirn[k];\r\n                    if (mcon > nact)\r\n                    {\r\n                        var kl = nact + 1;\r\n                        for (var k = kl; k <= mcon; ++k)\r\n                        {\r\n                            var kk = iact[k];\r\n                            var total = resmax - b[kk];\r\n                            var sumabs = resmax + Math.abs(b[kk]);\r\n                            for (var i = 1; i <= n; ++i)\r\n                            {\r\n                                temp = a[i][kk] * dxnew[i];\r\n                                total += temp;\r\n                                sumabs += Math.abs(temp);\r\n                            }\r\n                            var acca = sumabs + 0.1 * Math.abs(total);\r\n                            var accb = sumabs + 0.2 * Math.abs(total);\r\n                            if (sumabs >= acca || acca >= accb) total = 0.0;\r\n                            vmultd[k] = total;\r\n                        }\r\n                    }\r\n\r\n                    //     Calculate the fraction of the step from DX to DXNEW that will be taken.\r\n\r\n                    ratio = 1.0;\r\n                    icon = 0;\r\n                    for (var k = 1; k <= mcon; ++k)\r\n                    {\r\n                        if (vmultd[k] < 0.0)\r\n                        {\r\n                            temp = vmultc[k] / (vmultc[k] - vmultd[k]);\r\n                            if (temp < ratio)\r\n                            {\r\n                                ratio = temp;\r\n                                icon = k;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //     Update DX, VMULTC and RESMAX.\r\n\r\n                    temp = 1.0 - ratio;\r\n                    for (var k = 1; k <= n; ++k) dx[k] = temp * dx[k] + ratio * dxnew[k];\r\n                    for (var k = 1; k <= mcon; ++k)\r\n                        vmultc[k] = Math.max(0.0, temp * vmultc[k] + ratio * vmultd[k]);\r\n                    if (mcon == m) resmax = resold + ratio * (resmax - resold);\r\n\r\n                    //     If the full step is not acceptable then begin another iteration.\r\n                    //     Otherwise switch to stage two or end the calculation.\r\n\r\n                } while (icon > 0);\r\n                \r\n                if (step == stpful) return true;\r\n                \r\n            } while (true);\r\n\r\n            //     We employ any freedom that may be available to reduce the objective\r\n            //     function before returning a DX whose length is less than RHO.\r\n\r\n        } while (mcon == m);\r\n\r\n        return false;\r\n    }\r\n        \r\n    function PrintIterationResult(nfvals, f, resmax,  x,  n, iprint)\r\n    {\r\n        if(iprint>1) console.log(\"NFVALS = \"+nfvals+\"  F = \"+f+\"  MAXCV = \"+resmax);\r\n        if(iprint>1) console.log(\"X = \"+PART(x, 1, n));\r\n    }\r\n\r\n    function ROW( src, rowidx)\r\n    {\r\n        var cols = src[0].length;\r\n        var dest = arr(cols);\r\n        for (var col = 0; col < cols; ++col) dest[col] = src[rowidx][col];\r\n        return dest;\r\n    }\r\n\r\n   function COL(src, colidx)\r\n    {\r\n        var rows = src.length;\r\n        var dest = arr(rows);\r\n        for (var row = 0; row < rows; ++row) dest[row] = src[row][colidx];\r\n        return dest;\r\n    }\r\n\r\n    function PART(src, from, to)\r\n    {\r\n      return src.slice(from,to+1);\r\n    }\r\n    /*\r\n     function PART(src, from, to)\r\n     {\r\n     var dest = arr(to - from + 1);\r\n     var destidx = 0;\r\n     for (var srcidx = from; srcidx <= to; ++srcidx, ++destidx) dest[destidx] = src[srcidx];\r\n     return dest;\r\n     }*/\r\n\r\n     /*\r\n    function FORMAT( x)\r\n    {\r\n        var fmt = \"\";\r\n        for (var i = 0; i < x.length; ++i) fmt = fmt + \", \", x[i];\r\n        return fmt;\r\n    }*/\r\n\r\n    function DOT_PRODUCT( lhs,  rhs)\r\n    {\r\n        var sum = 0.0; for (var i = 0; i < lhs.length; ++i) sum += lhs[i] * rhs[i];\r\n        return sum;\r\n    }\r\n\r\n","import React, {Component} from 'react';\nimport './Kelly.css';\nimport MathJax from 'react-mathjax';\nimport {FindMinimum} from './Cobyla'\n\nclass Dec2BinTool extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            win1 : 0,\n            odds1 : 0,\n            bankroll1: 0,\n            result1: 0,\n            return1: 0,\n            kellyM : [{win: 0, odds: 0, result: 0}, ],\n            bankrollM: 0,\n            returnM: 0,\n            rowM: 1,\n            //stock 1\n            bankrollS1: 0,\n            meanS1: 0,\n            stdS1: 0,\n            optFS1: 0,\n            expectRS1: 0,\n            //stock 2 \n            bankrollS2: 0,\n            pS2: 0,\n            qS2: 0,\n            gainS2: 0,\n            lossS2: 0,\n            optFS2: 0,\n        }\n    }\n\n    kelly1 = (bankroll, win, odds) => {\n        console.log(\"R\", bankroll, win, odds);\n        var fbankroll = parseFloat(bankroll)\n        var fwin = parseFloat(win)\n        var fodds = parseFloat(odds)\n\n        return fbankroll * (fwin - (1-fwin)/fodds);\n    }\n\n    kellyStock1 = (bankroll, mean, std) => {\n        //return the optimal f and the expected return\n        var fbankroll = parseFloat(bankroll);\n        var fmean = parseFloat(mean);\n        var fstd = parseFloat(std);\n        var opt_f = fmean/fstd/fstd;\n        var ret = 0.5 * fmean * fmean / fstd / fstd;\n\n        return [fbankroll* opt_f, ret];\n    }\n\n    setBankroll1 = (value) => {\n        //const parsed = parseFloat(value)\n        //if(isNaN(parsed)) return;\n        this.setState({bankroll1: value, result1: this.kelly1(value, this.state.win1, this.state.odds1)})\n    }\n\n    setWin1 = (value) => {\n        //const parsed = parseFloat(value)\n        //if(isNaN(parsed)) return;\n        this.setState({win1: value, result1: this.kelly1(this.state.bankroll1, value, this.state.odds1)})\n    }\n\n    setOdds1 = (value) => {\n        //const parsed = parseFloat(value)\n        //if(isNaN(parsed)) return;\n        this.setState({odds1: value, result1: this.kelly1(this.state.bankroll1, this.state.win1, value)})\n    }\n\n    setBankrollM = (value) => {\n        this.setState({bankrollM: value,});\n    }\n\n    handleWinMChange = (index, value) => {\n        var items = this.state.kellyM;\n        items[index].win  = value;\n\n        this.setState({\n            kellyM: items\n        });\n    }\n\n    handleOddsMChange = (index, value) => {\n        var items = this.state.kellyM;\n        items[index].odds  = value;\n\n        this.setState({\n            kellyM: items\n        });\n    }\n\n    setRowM = (value) => {\n        this.setState(\n            {rowM: value, }\n        );\n    }\n\n    handleRowChange = () => {\n        let curLen = this.state.kellyM.length;\n        if(curLen === this.state.rowM) return;\n\n        if(curLen > this.state.rowM){\n            var rlen=  this.state.rowM-curLen;\n            this.state.kellyM.splice(rlen);\n        }\n        else{\n            while(this.state.kellyM.length < this.state.rowM)\n                this.state.kellyM.push({win: 0, odds: 0, result: 0})\n        }\n        this.setState(\n            {kellyM: this.state.kellyM }\n        )\n    }\n\n    setBankRollS1 = (value) => {\n        var optF, ret;\n        [optF, ret] = this.kellyStock1(value, this.state.meanS1, this.state.stdS1);\n\n        this.setState({\n            bankrollS1: value, \n            optFS1: optF,\n            expectRS1: ret,\n        });\n\n    }\n\n    setMeanS1 = (value) => {\n        var optF, ret;\n        [optF, ret] = this.kellyStock1(this.state.bankrollS1, value, this.state.stdS1);\n\n        this.setState({\n            meanS1: value, \n            optFS1: optF,\n            expectRS1: ret,\n        });\n\n    }\n\n    setStdS1 = (value) => {\n        var optF, ret;\n        [optF, ret] = this.kellyStock1(this.state.bankrollS1, this.state.meanS1, value);\n\n        this.setState({\n            stdS1: value, \n            optFS1: optF,\n            expectRS1: ret,\n        });\n    }\n\n\n    async componentDidMount(){\n    }\n \n    loadDebug = () => {\n        //0.229, 0.457, 0.0571, 0.114, 0.143\n        this.setState({\n            bankrollM: 10000,\n            rowM: 5,\n            kellyM: [{win: 0.229, odds: 4, result: 0}, \n                {win: 0.457, odds: 4, result: 0}, \n                {win: 0.0571, odds: 4, result: 0}, \n                {win: 0.114, odds: 4, result: 0}, \n                {win: 0.143, odds: 4, result: 0}, \n            ]\n        });\n    }\n\n    createRandomStart = (x, maxValue) => {\n        for(var i=0; i<x.length; ++i)\n            x[i] =  Math.floor(Math.random() * maxValue);\n    }\n\n    hanldeSubmit = () => {\n        var n=this.state.rowM; \t\t\t// + of variables\n        var x=new Array(n);\n        var m=this.state.rowM+1; \t\t\t// number of constraints\n        var rhobeg = 20.0;\t// Various Cobyla constants, see Cobyla docs in Cobyja.js\n        var rhoend = 1.0e-6;\n        var iprint = 0;\n        var maxfun = 3500;\n        var fmaxiter = 20;\n\n        //now convert the whole data into float\n        var fodds = [];\n        var fwin = [];\n        for(var i=0; i<n; ++i){\n            fwin.push(parseFloat(this.state.kellyM[i].win));\n            fodds.push(parseFloat(this.state.kellyM[i].odds));\n        }\n\n        var fbankroll = parseFloat(this.state.bankrollM);\n\n        console.log(\"Here are the calculation argument.\");\n        console.log(fwin);\n        console.log(fodds);\n        console.log(fbankroll);\n\n        function test(n,m,x,con) {  \t// objective function\n            var sumB = 0;\n            for(var i=0; i<n; ++i)\n                sumB += x[i];\n\n            var g = 0;\n            for(var i=0; i<n; ++i){\n                con[i] = x[i];\n                g = g + fwin[i] * Math.log(fbankroll + x[i] * fodds[i] - sumB);\n            }\n            g = -Math.exp(g); \n            con[n] = fbankroll - sumB;\n            //console.log(\"x: \"+ x);\n            //console.log(\"g: \"+ g);\n            return g //to minimize\n        }\n\n        //debug \n        //x[0] = 714.2797;\n        //x[1] = 2999.99;\n\n        var bestx = null;\n        var bestG = 0;\n\n        //This implementation cannot converge, so I just random sample starting point to make it better.\n        for(var i=0; i<200; ++i){\n            this.createRandomStart(x, fbankroll/n);\n            //x[i] = 0;\n            //console.log(\"start x: \"+ x);\n            var r=FindMinimum(test, n,  m, x, rhobeg, rhoend,  iprint,  maxfun, fmaxiter);\n            var curG = this.calcG(x, fbankroll, fwin, fodds);\n            if(curG < bestG){\n                bestG = curG;\n                bestx = x;\n            }\n        }\n        \n        //now update all the param and set state\n        for(var i=0; i<n; ++i){\n            this.state.kellyM[i].result = bestx[i].toFixed(2);\n        }\n\n        this.setState({\n            kellyM: this.state.kellyM\n        });\n\n    }\n\n    calcG = (x, fbankroll, fwin, fodds) => {\n        var n = x.length;\n        var sumB = 0;\n        for(var i=0; i<n; ++i)\n            sumB += x[i];\n\n        var g = 0;\n        for(var i=0; i<n; ++i){\n            g = g + fwin[i] * Math.log(fbankroll + x[i] * fodds[i] - sumB);\n        }\n        return -Math.exp(g); \n    }\n\n    kellyStock2 = (bankroll, p, q, a, b) => {\n        var fbankroll = parseFloat(bankroll);\n        var fp = parseFloat(p);\n        var fq = parseFloat(q);\n        var fa = parseFloat(a);\n        var fb = parseFloat(b);\n\n        return fbankroll * (fp/fa - fq/fb);\n    }\n\n    setBankrollS2 = (value) => {\n        var optF = this.kellyStock2(value, this.state.pS2, this.state.qS2, this.state.gainS2, this.state.lossS2);\n\n        this.setState({\n            bankrollS2: value, \n            optFS2: optF,\n        });\n    }\n\n    setPS2 = (value) =>{\n        var optF = this.kellyStock2(this.state.bankrollS2, value, this.state.qS2, this.state.gainS2, this.state.lossS2);\n\n        this.setState({\n            pS2: value, \n            optFS2: optF,\n        });\n    }\n\n    setAS2 = (value) => {\n        var optF = this.kellyStock2(this.state.bankrollS2, this.state.pS2, this.state.qS2, value, this.state.lossS2);\n\n        this.setState({\n            gainS2: value, \n            optFS2: optF,\n        });\n    }\n\n    setQS2 = (value) =>{\n        var optF = this.kellyStock2(this.state.bankrollS2, this.state.pS2, value, this.state.gainS2, this.state.lossS2);\n\n        this.setState({\n            qS2: value, \n            optFS2: optF,\n        });\n    }\n\n    setBS2 = (value) => {\n        var optF = this.kellyStock2(this.state.bankrollS2, this.state.pS2, this.state.qS2, this.state.gainS2, value);\n\n        this.setState({\n            lossS2: value, \n            optFS2: optF,\n        });\n    }\n\n    render(){\n\n        let simpleKelly = `f^*  = p - \\\\frac{1-p}{b}`;\n        let stock1Kelly = `f^* = \\\\frac{\\\\mu}{\\\\sigma^2}`;\n        let stock1KellyReturn = `E(return) = 0.5 * \\\\frac{\\\\mu^2}{\\\\sigma^2}`;\n        let stock2Kelly = `f^* = \\\\frac{p}{a} - \\\\frac{q}{b}`;\n        let horseKelly1 = `\\\\underset{B}{\\\\text{max}} \\\\qquad G =  \\\\sum_{i=1}^{n} ln(T + B_i * O_i - \\\\sum_{i=1}^{n} B_i) `;\n        let horseKelly2 = `\\\\displaylines{ \\\\text{subject to} \\\\qquad B \\\\geq 0 \\\\\\\\ and \\\\qquad \\\\sum_{i=1}^{n} B_i \\\\leq bankroll }`;\n        let kellyInputStyle = {\n            minWidth:\"150px\", display:\"inline-block\", marginLeft: 25, marginRight: 25,\n            textAlign: \"right\",\n        };\n\n        return(\n\n            \n            <MathJax.Provider> \n                <div className=\"main\">\n                    <h1>\n                        Kelly calculator\n                    </h1>\n                    <p>Tools for win/loss, stock and horse win scenario </p>\n                    <br/>\n                    <div>\n                        <p> COBYLA Code URL: <a href=\"https://github.com/smee/cobyla2\">Github</a> </p>\n                        <p> Paul Wilmott on Quantitative Finance, Chapter 17, Kelly criterion <a href=\"https://github.com/smee/cobyla2\">Youtube</a> </p>\n                        <p> Kelly wiki <a href=\"https://en.wikipedia.org/wiki/Kelly_criterion\">Link</a> </p>\n                    </div>\n                    <br/><br/>\n                    <div className=\"table\">\n                        <div className=\"tr\">\n                            <p>For a game, the kelly criterion can be calculated as follow:</p>\n                            <MathJax.Node formula={simpleKelly} />\n                        </div>\n                        <div className=\"tr\">\n                            <form>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Bankroll: </div>\n                                <input\n                                style={{ width:\"200px\"}}\n                                type=\"number\" \n                                value={this.state.bankroll1}\n                                onChange={(e) => this.setBankroll1(e.target.value)}\n                                />\n                            </label>\n                            <br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Wins: </div>\n                                <input\n                                type='number'\n                                step=\"0.1\"\n                                min='0'\n                                max='99999'\n                                style={{ width:\"200px\" }}\n                                value={this.state.win1}\n                                onChange={(e) => this.setWin1(e.target.value)}\n                                />\n                            </label><br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Odds: </div>\n                                <input\n                                type=\"number\" \n                                step=\"0.1\"\n                                min='0'\n                                max='1'\n                                style={{ width:\"200px\" }}\n                                value={this.state.odds1}\n                                onChange={(e) => this.setOdds1(e.target.value)}\n                                />\n                            </label><br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Result: </div>\n                                <input\n                                type=\"text\" \n                                readOnly={true}\n                                style={{ width:\"200px\" }}\n                                value={this.state.result1}\n                                />\n                            </label>\n                            </form>\n                        </div>\n                    </div>\n\n                    <div className=\"table\">\n                        <div className=\"tr\">\n                            <p>For stock, i have a strategy, with average return μ and standard deviation σ, calculate how much I should bet on it.</p>\n                            <MathJax.Node formula={stock1Kelly} />\n                            <MathJax.Node formula={stock1KellyReturn} />\n                        </div>\n                        <div className=\"tr\">\n                            <form>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Bankroll: </div>\n                                <input\n                                style={{ width:\"200px\"}}\n                                type=\"number\" \n                                value={this.state.bankrollS1}\n                                onChange={(e) => this.setBankRollS1(e.target.value)}\n                                />\n                            </label>\n                            <br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Mean: </div>\n                                <input\n                                type='number'\n                                style={{ width:\"200px\" }}\n                                value={this.state.meanS1}\n                                onChange={(e) => this.setMeanS1(e.target.value)}\n                                />\n                            </label><br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Standard deviation: </div>\n                                <input\n                                type=\"number\" \n                                style={{ width:\"200px\" }}\n                                value={this.state.stdS1}\n                                onChange={(e) => this.setStdS1(e.target.value)}\n                                />\n                            </label><br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Optimal f*: </div>\n                                <input\n                                type=\"text\" \n                                readOnly={true}\n                                style={{ width:\"200px\" }}\n                                value={this.state.optFS1}\n                                />\n                            </label><br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> E(return): </div>\n                                <input\n                                type=\"text\" \n                                readOnly={true}\n                                style={{ width:\"200px\" }}\n                                value={this.state.expectRS1}\n                                />\n                            </label>\n                            </form>\n                        </div>\n                    </div>\n\n                    <div className=\"table\">\n                        <div className=\"tr\">\n                            <p>For stock, i have a trade with profit taker and loss taker, calculate how much bet I need</p>\n                            <MathJax.Node formula={stock2Kelly} />\n                        </div>\n                        <div className=\"tr\">\n                            <form>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Bankroll: </div>\n                                <input\n                                style={{ width:\"200px\"}}\n                                type=\"number\" \n                                value={this.state.bankrollS2}\n                                onChange={(e) => this.setBankrollS2(e.target.value)}\n                                />\n                            </label>\n                            <br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Win prob(p): </div>\n                                <input\n                                type='number'\n                                step=\"0.1\"\n                                min='0'\n                                max='1'\n                                style={{ width:\"200px\" }}\n                                value={this.state.pS2}\n                                onChange={(e) => this.setPS2(e.target.value)}\n                                />\n                            </label><br/>\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Gain% (b): </div>\n                                <input\n                                type=\"number\" \n                                step=\"0.1\"\n                                style={{ width:\"200px\" }}\n                                value={this.state.lossS2}\n                                onChange={(e) => this.setBS2(e.target.value)}\n                                />\n                            </label><br/>\n\n                            \n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Loss prob(p): </div>\n                                <input\n                                type='number'\n                                step=\"0.1\"\n                                min='0'\n                                max='1'\n                                style={{ width:\"200px\" }}\n                                value={this.state.qS2}\n                                onChange={(e) => this.setQS2(e.target.value)}\n                                />\n                            </label><br/>\n\n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Loss% (a): </div>\n                                <input\n                                type=\"number\" \n                                step=\"0.1\"\n                                style={{ width:\"200px\" }}\n                                value={this.state.gainS2}\n                                onChange={(e) => this.setAS2(e.target.value)}\n                                />\n                            </label><br/>\n                            \n                            <label>\n                                <div style={{ minWidth:\"150px\", display:\"inline-block\"}}> Optimial: </div>\n                                <input\n                                type=\"text\" \n                                readOnly={true}\n                                style={{ width:\"200px\" }}\n                                value={this.state.optFS2}\n                                />\n                            </label>\n                            </form>\n                        </div>\n                    </div>\n\n                    <div className=\"table\">\n\n                        <div className=\"tr\">\n                            <p>This is for horse win scenario, P is the probability vector, B is the vector of bet, O is vector of odds</p>\n                            <p>This impl. use COBYLA for non-linear optimzation</p>\n                            <MathJax.Node formula={horseKelly1} />\n                            <MathJax.Node formula={horseKelly2} />\n                        </div>\n\n                        <div className=\"tr\">\n                        <form>\n                            <label style={{ minWidth:\"150px\", display:\"inline-block\"}}>Bank roll: </label>\n                            <input type=\"number\" name=\"bankroll\" value={this.state.bankrollM} onChange={e => this.setBankrollM(e.target.value)} />\n                            <div>\n                                <label style={{ minWidth:\"200px\", display:\"inline-block\"}}>Win</label>\n                                <label style={{ minWidth:\"200px\", display:\"inline-block\"}}>Odds</label>\n                                <label style={{ minWidth:\"200px\", display:\"inline-block\"}}>Result</label>\n                            </div>\n                            {this.state.kellyM.map((element, index) => (\n                                <div className=\"form-inline\" key={index}>\n                                \n                                <input style={kellyInputStyle} type=\"number\" name=\"win\" value={element.win} onChange={e => this.handleWinMChange(index, e.target.value)} />\n                                \n                                <input style={kellyInputStyle} type=\"number\" name=\"odds\" value={element.odds} onChange={e => this.handleOddsMChange(index, e.target.value)} />\n                                \n                                <input style={kellyInputStyle} type=\"number\" name=\"kelly\" readOnly={true} value={element.result}/>\n                                </div>\n                            ))}\n                            <br/>\n                            <div className=\"button-section\">\n                                <input type=\"number\" name=\"rownumber\" value={this.state.rowM} onChange={e => this.setRowM(e.target.value)}/>  \n                                <button className=\"button add\" type=\"button\" onClick={() => this.handleRowChange()}>Change</button>\n                                <button className=\"button add\" type=\"button\" onClick={() => this.loadDebug()}>Debug</button>\n                                <button className=\"button submit\" type=\"button\" onClick={this.hanldeSubmit}>Calculate</button>\n                            </div>\n                        </form>\n                        </div>\n                    </div>\n                    <br/>\n                    <br/>\n                    <br/>\n                    <div>Written by tom</div>\n                </div> \n            </MathJax.Provider> \n        )\n    }\n}\n\n/*\n<label style={{ minWidth:\"100px\", display:\"inline-block\"}}>Win</label><label style={{ minWidth:\"100px\", display:\"inline-block\"}}>Odds</label><label style={{ minWidth:\"100px\", display:\"inline-block\"}}>Result</label>\n*/\n\nexport default Dec2BinTool;","import React from 'react';\nimport {\n  HashRouter, Route \n} from \"react-router-dom\";\nimport './App.css';\nimport ToolList from './components/ToolList.js'\nimport Dec2BinTool from './components/Dec2BinTool'\nimport ReverseStr from './components/ReverseStr'\nimport MultiLine from './components/MultiLine'\nimport Kelly from './components/Kelly'\n\nfunction App() {\n  return (\n\n    <HashRouter basename=\"/mytool\"> \n      <div>\n        <Route exact path=\"/\" component={ToolList} />\n        <Route path=\"/dec2bin\" component={Dec2BinTool} />\n        <Route path=\"/reverseStr\" component={ReverseStr} />\n        <Route path=\"/multiLine\" component={MultiLine} />\n        <Route path=\"/kelly\" component={Kelly} />\n      </div>\n    </HashRouter>\n  );\n}\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}